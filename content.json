[{"title":"Java(五)：对象持有","date":"2017-05-23T02:37:19.000Z","path":"2017/05/23/Java(五)：对象持有/","text":"综述： 数组跟容器的区别Java中有多种方式保存对象，数组是比较轻量级的一种，它是编译器支持的类型，缺点是数组的大小固定。所以Java提供另外一种方式保存对象——Collection。集合类的大小可以动态扩展，基于Collection的不同子类分别对容器的不同需求做了优化，见下表： 类型 特点 List 按照被插入顺序保存元素，同一个对象可以重复放 Set 每个相同的项之保存一次 Queue 队列,先进先出（FIFO）容器 Map 使用键值对保存对象 Collection基本操作 12345678910111213141516171819202122//初始化Collection&lt;Integer&gt; collection = new ArrayList&lt;&gt;(); //容器内没有元素collection = new ArrayList&lt;&gt;(Arrays.asList(1,2,3));Collections.addAll(collection,1,2,3,4); //把元素加入到Collection中collection = Arrays.asList(1,2,3,4); //Arrays.asList返回的是Arrays里面的ArrayList，底层是数组，所点调用add（）会报错//添加元素collection.add(1);//删除元素collection.remove(1);//工具Collections.sort(collection); //倒叙容器里面的所有元素Collections.nCopies(int n,Object);Collections.fill(collection,object); //Collection的每个元素用object代替 ListList按照被插入顺序保存元素， ArrayList在进行随机访问时候比较快，但是在list的中间插入和移除元素表较慢 LinkedList 与ArraList优缺点相反 Set使用键值对保存对象 HashSet 散列函数 快速访问 hashCode() TreeSet 红黑树结构 键始终保持排序 comparable() LinkedHashSet 继承于HashSet 保持插入顺序 hashCode() Map不保存重复元素（怎么才叫重复）使用hashCode找到键在哪，使用equals判断键是否重复 HashMap 散列函数 快速访问 TreeMap 红黑树结构 始终保持排序 LinkedHashMapt 继承于HashMap 保持插入顺序 Queue允许重复对象 LinkedList 123456Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();queue.offer(1); //在允许的情况下将一个元素插入到队尾queue.peek(); //返回对头但不移除，队列为空时返回nullqueue.element(); //返回对头但不移除，队列为空时抛出NoSuchElementExceptionqueue.poll(); //返回对头且移除，队列为空时返回nullqueue.remove(); //返回对头且移除，队列为空时抛出NoSuchElementException PriorityQueue队列是先进先出的容器，PriorityQueue提供了优先级服务，通过Comparator来比较优先级。 容器 底层结构 特点 ArrayList 数组 随机访问快，编译器支持数组，用下标访问元素快 LinkedList 双向链表 数组插入或删除元素，后面的元素都要改变，但链表只需要改变前后的指针 HashMap 数组元素是单向链表 随机访问快 LinkedHashMap 基于HashMap 排序key TreeMap 单向链表 保存插入顺序 遍历InteratorCollection继承于Iterable，所以Collection子类可以获得一个iterator来遍历容器。 12345Iterator iter = l.iterator();while(iter.hasNext())&#123; String str = (String) iter.next(); System.out.println(str);&#125; foreach实现Iterable的类都可以使用foreach遍历 散列散列的目是用一个对象查找另一个对象","tags":[{"name":"对象持有","slug":"对象持有","permalink":"http://yoursite.com/tags/对象持有/"}]},{"title":"Java(四)：内部类","date":"2017-05-22T01:30:31.000Z","path":"2017/05/22/Java(四)：内部类/","text":"将一个类的定义放在另一个类的定义内部，这就是内部类。 内部类分为成员内部类、静态内部类、局部方法内部类和匿名内部类，成员内部类跟类属性声明一样，静态内部类需要加static限定符，局部方法内部类是在方法声明的类，匿名内部类用来生成一个对象。 成员内部类基本用法与内部类对应的是外围类。成员内部类能访问外围类对象的所有成员。当某个外围类的对象创建了一个成员内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。成员内部类的对象只能在于其外围类的对象相关联的情况下才能被创建。静态内部类（嵌套类）则不需要对外部类对象的引用。 12345678910111213141516171819public class OuterClass &#123; public class InnerClass&#123; public OuterClass getOuter()&#123; return OuterClass.this; &#125; &#125; public InnerClass getInnerClass()&#123; return new InnerClass(); &#125;&#125;//获取内部类1、 OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.getInnerClass();2、 OuterClass.InnerClass innerClass = outerClass.new InnerClass(); 成员内部类必须有外围类与之关联，且外围类先于成员内部类初始化，所以成员内部类不能有静态数据和属性。可以调用外围类的new方法调用成员内部类的构造器，在成员内部类里面使用.this获取其外围类。 成员内部类的继承成员内部类初始化之前其外围类必须已经初始化了。在继承成员内部类的时候，继承的类在初始化之前也必须有被继承成员内部类的外围类与之关联且这个外围类初始化现已继承类，但是这个继承类并没有外围类的引用，所以可以这样：1234567public class SubInnerClass extends OuterClass.InnerClass &#123; public SubInnerClass(OuterClass outerClass)&#123; outerClass.super(); &#125;&#125; 作用外围类可以拥有多个成员内部类，每个成员内部类只能继承一个类或者实现一个接口，所以可以可以使用这种方法实现“多继承”，其实跟组合的效果差不多。 静态内部类静态内部类与成员内部类的写法差不多，只需要加static限定符。静态内部类不需要关联外围类，所以它也不能访问非静态的外围类对象。静态内部类可以包含静态数据。 123456public class OuterClass &#123; public static class InnerClass&#123; private int a; private static int b; &#125;&#125; 静态内部类就想把像个类放到一个文件里面，用法跟不同的两个类一样，常用语Builder模式，这个静态内部类专门服务于外围类。 局部方法内部类局部方法内部类是在方法里面声明的类，它的作用域只是在方法内，不希望公布到其他使用，开发中一般很少使用。 1234567891011121314public class Outer &#123; private String x = &quot;outer&quot;; public void doStuff() &#123; class MyInner &#123; public void seeOuter() &#123; System.out.println(&quot;x is &quot; + x); &#125; &#125; MyInner i = new MyInner(); i.seeOuter(); &#125; &#125; 匿名内部类匿名内部类用来声明一个继承于一个类或实现一个接口的类，这个类没有class关键字也没有名字，所以只能使用一次。 1234new 父类构造器（参数列表）|实现接口（） &#123; //匿名内部类的类体部分 &#125; 匿名内部类一些限定： 匿名内部类只能继承一个类或者实现一个接口。 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 匿名内部类一般用于callback的回调对象使用，需要注意的是当匿名内部类使用方法的形参时，方法的形参必须声明为final，因为方法执行完后也就超出形参的作用域，声明为final可以扩大他的声明周期。 1234567891011121314151617181920212223public class OutClass &#123; public InnerClass getInnerClass(final int age,final String name)&#123; return new InnerClass() &#123; int age_ ; String name_; //构造代码块完成初始化工作 &#123; if(0 &lt; age &amp;&amp; age &lt; 200)&#123; age_ = age; name_ = name; &#125; &#125; public String getName() &#123; return name_; &#125; public int getAge() &#123; return age_; &#125; &#125;; &#125; &#125;","tags":[{"name":"内部类","slug":"内部类","permalink":"http://yoursite.com/tags/内部类/"}]},{"title":"Android缓存之内存缓存：LruCache","date":"2017-05-11T02:54:30.000Z","path":"2017/05/11/Android缓存之内存缓存：LruCache/","text":"应用使用一个资源时会加载到内存中，资源使用后如果内存足够的情况下可以先不回收，若下次又使用了同一个资源，可直接到内存中加载，这样会使资源可以被重复利用，同时优化用户体验。不过这一部分资源不具有实时性，例如图片、多媒体资源。Android中有LruCache帮助开发者缓存资源到内存。 在过去，一种比较流行的内存缓存实现方法是使用软引用（SoftReference）或弱引用（WeakReference）对Bitmap进行缓存,然而我们并不推荐这样的做法。从Android 2.3 (API Level 9)开始，垃圾回收机制变得更加频繁，这使得释放软（弱）引用的频率也随之增高，导致使用引用的效率降低很多。而且在Android 3.0 (API Level 11)之前，备份的Bitmap会存放在Native Memory中，它不是以可预知的方式被释放的，这样可能导致程序超出它的内存限制而崩溃。 —by Google","tags":[{"name":"Cache","slug":"Cache","permalink":"http://yoursite.com/tags/Cache/"}]},{"title":"Android缓存之存储目录","date":"2017-05-10T11:06:39.000Z","path":"2017/05/10/Android缓存之存储目录/","text":"Android储存分为内部储存（InternalStorage）和外部储存（ExternalStorage），Apk安装在内部储存中，这部分空间有限，所以一般的缓存数据不会放到这里。 内部存储data文件夹就是我们常说的内部存储，/data/app里存放着我们所有安装的app的apk文件。data/data/包名/下面放的就是对应应用的文件： /data/data/包名/shared_prefs //sharedPreferenced生成的xml /data/data/包名/databases //SQL文件 /data/data/包名/files //普通文件 /data/data/包名/cache //缓存文件 Android获取内部存储的api： 123456789101112getFileDir() -&gt; /data/data/pacgage_name/filesgetCacheDir() -&gt; /data/data/package_name/cacheopenFileOutput() -&gt; /data/data/package_name/filesOutputStream outputStream = openFileOutput(&quot;openFileOutput.txt&quot;, MODE_PRIVATE); //从技术上讲，如果你设置文件为可读的，那么其他app就可以读取你的internal文件。然而，其他app需要知道你的包名与文件名。若是你没有设置为可读或者可写，其他app是没有办法读写的。因此只要你使用MODE_PRIVATE ，那么这些文件就不可能被其他app所访问。 外部存储外部储存的根目录是 /storage/emulated/0，这个根目录下也有一个data/data/pacgage_name文件夹，有没有cache和file文件夹，跟内部存储的那两个文件夹一样。当然也可以在外部存储data外新建特定的文件夹存放缓存数据，但是这样他的数据就一定可以被其他应用访问。 Android获取外部存储的api： 123456789101112getExternalCacheDir() -&gt; /storage/emulated/0/data/data/package_name/cachegetExternalFilesDir() -&gt; /storage/emulated/0/data/data/package_name/files//使用Environment访问外部存储的其他目录Environment.getExternalStorageDirectory() if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) &#123; cachePath = context.getExternalCacheDir().getPath(); &#125; 当应用被卸载的时候内部存储和外部存储的包名文件夹都被删除，当点击应用程序管理对应程序的清理数据或缓存按钮时或者软件清理缓存时，包名下的cache和file目录会被清除，所以有些数据不希望被清除的话，可以在外部存储非data目录新建应用私有目录存放数据，不过这部分数据就能被其他程序访问，用户也可以通过文件夹管理软件看到。","tags":[{"name":"Cache","slug":"Cache","permalink":"http://yoursite.com/tags/Cache/"}]},{"title":"Android缓存概述","date":"2017-05-08T03:08:04.000Z","path":"2017/05/08/Android缓存概述/","text":"应用中经常从服务器中获取资源，像一些非实时性的资源重复请求的话会造成流量的浪费，如果请求的资源比较大也会造成用户体验差，用户网络不好的情况下需要等待加载，例如在线听歌同一首歌没必要每次听的时候都要重新加载，新闻类的资源没必要每次都重新获取，图片资源也不需要重新加载。。。 使用内存和文件的方式实现。用户请求资源的时候先从内存中找没有资源的缓存，如果没有的话再去文件缓存中找，还是没有的还就到服务请求。缓存的算法使用LRU（Least Rencetly Used），资源最近使用会被放到链表头，缓存溢出时，链表尾的数据会被删除。 Android缓存之存储目录 Android缓存之内存缓存：LruCache Android缓存之文件存储 LinkedHashMap 一.保存到内部存储的方式 存储目录http://blog.csdn.net/zhaokaiqiang1992/article/details/43451931 getFileDir() /data/data/pacgage_name/filesgetCacheDir() /data/data/package_name/cacheopenFileOutput() /data/data/package_name/files cache与files的差别在于，如果手机的内部存储控件不够了，会自行选择cache目录进行删除 2.外部私有存储 getExternalCacheDir() /sdcard/Android/date/package_name/cache 在APP被卸载的时候，都会被系统删除 与内部存储不同，外部存储的容量一般较大，而且当移动设备连接到PC之后，如果我们开启USB模式与PC连接并操作文件，这个时候外部存储是处于卸载状态的，APP不能对里面的文件进行操作，所以，我们的APP的对外部存储进行操作之前，请先检查外部存储的状态。 3.外部公共存储Environment.getExternalStorageDirectory() Environment.getExternalStoragePublicDirectory()","tags":[{"name":"Cache","slug":"Cache","permalink":"http://yoursite.com/tags/Cache/"}]},{"title":"Java的四种引用","date":"2017-05-06T02:16:57.000Z","path":"2017/05/06/Java的四种引用/","text":"从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 强引用我们平常一样创建一个对象并赋给一个变量就是强引用。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。 1234//强引用 Object object = new Object(); //强引用，如果这个对象太大，超过内存，JVM会抛出异常，而不会回收这个对象 Object[] objArr = new Object[1000]; 当强引用的对象没有变量指向他或者它的生命周期结束了，JVM才会回收它。 软引用（SoftReference）如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它； 如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。 也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。 另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。 1234SoftReference aSoftRef=new SoftReference(new String(&quot;aaa&quot;)); String str = (String)aSoftRef.get();//如果aSoftRef被回收，str就为null； 作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法 1234567ReferenceQueue queue = new ReferenceQueue(); SoftReference ref=new SoftReference(aMyObject, queue); //需要定期清理一下无用软引用对象while ((ref = (EmployeeRef) q.poll()) != null) &#123; // 清除ref &#125; 弱引用弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。 12345 WeakReference&lt;People&gt; reference=new WeakReference&lt;People&gt;(new String(&quot;aaa&quot;)); String str = (String)reference.get();用法和软引用一样，也可用ReferenceQueue与之关联 虚引用（PhantomReference）“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 12ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;();PhantomReference&lt;String&gt; pr = new PhantomReference&lt;String&gt;(new String(&quot;hello&quot;), queue);","tags":[{"name":"内存优化","slug":"内存优化","permalink":"http://yoursite.com/tags/内存优化/"}]},{"title":"Android之进程保活","date":"2017-05-05T02:28:32.000Z","path":"2017/05/05/Android之进程保活/","text":"Android 不能静态注册的广播 Android 进程常驻 微信 Android 客户端后台保活经验分享 什么是进程保活进程杀不死 为什么要做进程保活有些应用希望一直提供一些服务，比如接受推送，IM与服务器维护一个长连接，或者根据系统广播做一些动作，但是一些系统广播必须动态监听，所以要把它注册到后台服务并确保服务不被杀死 进程会怎样被杀死 第一被系统干死； 第二被第三方安全软件干死，比如知名的有奇虎360、CleanMaster（当然包括是否有root权限，有无root天壤之别）； 第三就是被用户手动干死，比如小米自带的系统一键清理、手机设置里应用管理器的ForceClose 1、将Service设置为前台进程 在api 17以上会在手机状态栏里面生成Notification，并且前台进程只是优先级较高可以轻易被用户或者杀毒软件关掉 2、在service的onstart方法里返回 STATR_STICK 3、添加Manifest文件属性值为android:persistent=“true” 这个属性需要系统shareuid 4、覆写Service的onDestroy方法 5、添加广播监听android.intent.action.USER_PRESENT事件以及其他一些可以允许的事件 6、服务互相绑定 7、设置闹钟，定时唤醒 8、账户同步，定时唤醒 9、native层保活 5.0以下的非国产机才会有这样的漏洞。也就是说在force close的时候，系统忽略c进程的存在，5.0以上包括5.0的哪怕源生系统也会连同c进程一起清理掉，国产机就更不用说了。就算是这样，在5.0以下的非国产机上，如果安装了获取root权限的360\\cm的话，也是可以直接清理掉，也就是说会失效","tags":[{"name":"常用技术","slug":"常用技术","permalink":"http://yoursite.com/tags/常用技术/"}]},{"title":"Java（六）：注解","date":"2017-04-23T03:11:41.000Z","path":"2017/04/23/Java(六)：注解/","text":"","tags":[]},{"title":"Java（三）：初始化与清理","date":"2017-04-22T02:13:41.000Z","path":"2017/04/22/Java(三)：初始化与清理/","text":"OOP中的特例 Java中的对象是存放到堆中并用引用与之联系，但是为了效率和使用方便，Java也使用基本类型，基本类型与对象不同，Java需要创建变量，变量的值存放在栈中（栈的访问比堆高效）。 基本类型 大小 最小值 最大值 包装器类型 boolean - - - Boolean char 16 bits Unicode 0 Unicode 2^16 -1 Character byte 8 bits -128 127 Byte short 16 bits -2^15 2^15 - 1 Short int 32 bits -2^31 2^31 -1 Integer long 64 bits -2^63 2^63 -1 Long float 32 bits IEEE754 IEEE754 Float double 64 bits IEEE754 IEEE754 Double void - - - Void 所有数值类型都有正负号，所以不要去寻找无符号的数值类型boolean类型所占存储空间的大小没有明确指定","tags":[{"name":"基本类型","slug":"基本类型","permalink":"http://yoursite.com/tags/基本类型/"}]},{"title":"Java（二）：基本类型","date":"2017-04-22T02:12:41.000Z","path":"2017/04/22/Java(二)：基本类型/","text":"OOP中的特例 Java中的对象是存放到堆中并用引用与之联系，但是为了效率和使用方便，Java也使用基本类型，基本类型与对象不同，Java需要创建变量，变量的值存放在栈中（栈的访问比堆高效）。 基本类型 大小 最小值 最大值 包装器类型 boolean - - - Boolean char 16 bits Unicode 0 Unicode 2^16 -1 Character byte 8 bits -128 127 Byte short 16 bits -2^15 2^15 - 1 Short int 32 bits -2^31 2^31 -1 Integer long 64 bits -2^63 2^63 -1 Long float 32 bits IEEE754 IEEE754 Float double 64 bits IEEE754 IEEE754 Double void - - - Void 所有数值类型都有正负号，所以不要去寻找无符号的数值类型boolean类型所占存储空间的大小没有明确指定","tags":[{"name":"基本类型","slug":"基本类型","permalink":"http://yoursite.com/tags/基本类型/"}]},{"title":"Android之Service","date":"2017-04-22T02:11:41.000Z","path":"2017/04/22/Android之Service/","text":"Service是Android的组件之一。Service与Activity都是ContextWrapper扩展类，区别在于Service没有UI，所以Service一般用来处理运行后台的服务，例如后台音乐服务、后台下载服务，一般大厂会另外开启一个进程，在进程中开启一个服务接受推送信息或做进程保活。但Service也是运行在主线程的，Service和Thread的概念不一样，需要明确两者的区别，Service有利于程序架构更清晰。 生命周期Service有两种启动方式 通过startService启动 12345开启服务：startService(new Intent(MainActivity.this, ServiceA.class));停止服务：stopService(new Intent(MainActivity.this, ServiceA.class)); 第一次开启服务时(startService)，ServiceA调用： -&gt;onCreate -&gt;onStartCommand 再开启服务时(startService)，ServiceA不会再调用onCreate，只会调用onStartCommand。在任意地方都可以调用stopService，如果Service没有开启调用stopService不会crash 通过bindService启动服务 1234567891011121314151617181920212223 private ServiceA.MyBinder myBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; LogUtil.e(&quot;onServiceConnected&quot;); myBinder = (ServiceA.MyBinder) service; &#125; &#125;;开启服务：Intent bindIntent = new Intent(MainActivity.this, ServiceA.class); bindService(bindIntent, connection, BIND_AUTO_CREATE);停止服务：unbindService(connection); Service没开启的时候调用bindService： -&gt;onCreate -&gt;onBind 再调用unbindService停止服务，Service调用onDestroy。如果Service没有和这个组件bind的时候去unbind这个组件和Service会crash。 onRebind当Service在onStartCommand后，并且Service的onUnbind返回true，组件bind -&gt; unBind -&gt; bind Service会调用onRebind方法 总结： 一个组件只能和一个Service绑定一次，多次调用bindService，connection的onServiceConnected方法之后在第一次调用，只需要一次unbindService就能解除绑定 同一个组件调用startService和bindService（不分先后，Service的onCreate只会调用一次，后面那一次不调用），必须调用stopService和unbindService服务才能停止 当多个组件绑定Service时，必须所有组件都解除绑定，Service才停止，当然如果Service被startService启动过也必须stopService。 Service与ThreadService与Thread并无什么关系。Service是Android的四大组件之一，主要用来管理后台服务的。而Thread程序的最小运行单元，在Android中UI是不提倡进行耗时的操作的，所以用到子线程。Thread是在Activity创建还是在Service下是有区别的，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。 前台线程Service几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是Service的系统优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。如果你希望Service可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台Service。前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止Service被回收才使用前台Service，有些项目由于特殊的需求会要求必须使用前台Service 123456789101112131415@Overridepublic void onCreate() &#123; super.onCreate(); Intent intent = new Intent( this, SecondActivity. class); intent.putExtra( &quot;ficationId&quot;, 1); Notification.Builder builder = new Notification.Builder(this); PendingIntent contentIntent = PendingIntent.getActivity(this, 0, intent, 0); builder.setContentIntent(contentIntent); //设置了此项内容之后，点击通知栏的这个消息，就跳转到Activity builder.setSmallIcon(R.mipmap.ic_launcher); builder.setContentTitle( &quot;title&quot; ); builder.setContentText( &quot;content&quot; ); Notification notification = builder.build(); startForeground(1, notification); LogUtil.e(&quot;ServiceA onCreate&quot;);&#125; Android 保持Service不被Kill掉的方法–双Service守护 &amp;&amp; Android实现双进程守护 Remote Service远程服务一般用于为其他进程提供统一服务，例如天气查询、支付等，这就涉及到不同进程间通讯的问题，远程服务使用AIDL来建立进程间通讯接口（Broadcast和ContentProvider也可以）。 关于ADIL的创建：Android Studio中如何创建AIDL Android Studio中创建AIDL Service","tags":[{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"}]},{"title":"Android之Intent-filter","date":"2017-04-22T02:11:41.000Z","path":"2017/04/22/Android之Intent-filter/","text":"详解Android中Intent对象与Intent Filter过滤匹配过程 Activity Intent Flags及Task相关属性","tags":[{"name":"Intent-filter","slug":"Intent-filter","permalink":"http://yoursite.com/tags/Intent-filter/"}]},{"title":"Android之Broadcast","date":"2017-04-22T02:11:41.000Z","path":"2017/04/22/Android之Broadcast/","text":"如果你注册了一个类型的广播，当对应类型广播发送的时候你就能监听到。系统会在很多是时候发送一些特定的广播出来，例如，开机完成后会发出”android.intent.action.BOOT_COMPLETED”的广播；网络状态变化时发出”android.net.conn.CONNECTIVITY_CHANGE”的广播；电量变化时发出”android.intent.action.BATTERY_CHANGED”的广播…如果你想让一个应用开机启动，就可以监听对应的广播，当接收到广播的时候启动APP就行了。当然你也看自定义广播进行进程间或者进程内的消息传递 BroadcastReceiver是Android四大组件之一，onReceive方法在主线程执行。 注册方式静态注册1234567891011121314151617//1. 新建类继承BroadcastReceiverpublic class MyReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context arg0, Intent arg1) &#123; &#125;&#125;//2. 在AndroidManifest.xml文件中配置 &lt;receiver android:name=&quot;.MyReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MY_BROADCAST&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 动态注册在Activity或Service注册一个广播： 1234567891011MyReceiver receiver = new MyReceiver(); IntentFilter filter = new IntentFilter(); filter.addAction(&quot;android.intent.action.XXXX&quot;); registerReceiver(receiver, filter); //需要注销广播unregisterReceiver(receiver); 广播类型普通广播可以被所有订阅者受到并且不互相影响，与之相对的是有序广播（Ordered Broadcast），优先级比较高的订阅者先都到广播，并且这个订阅者有权终止这个广播向后传播 此处注册三个广播，intent-filter可以设置priority属性（-1000 ~ 1000），数值越大优先级越高123456789101112131415161718192021222324252627282930&lt;receiver android:name=&quot;.FirstReceiver&quot;&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;android.intent.action.MY_BROADCAST&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;.SecondReceiver&quot;&gt; &lt;intent-filter android:priority=&quot;999&quot;&gt; &lt;action android:name=&quot;android.intent.action.MY_BROADCAST&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=&quot;.ThirdReceiver&quot;&gt; &lt;intent-filter android:priority=&quot;998&quot;&gt; &lt;action android:name=&quot;android.intent.action.MY_BROADCAST&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; public void send(View view) &#123; Intent intent = new Intent(&quot;android.intent.action.MY_BROADCAST&quot;); intent.putExtra(&quot;msg&quot;, &quot;hello receiver.&quot;); sendOrderedBroadcast(intent, &quot;scott.permission.MY_BROADCAST_PERMISSION&quot;); &#125; /*注意，使用sendOrderedBroadcast方法发送有序广播时，需要一个权限参数，如果为null则表示不要求接收者声明指定的权限，如果不为null，则表示接收者若要接收此广播，需声明指定权限。这样做是从安全角度考虑的，例如系统的短信就是有序广播的形式，一个应用可能是具有拦截垃圾短信的功能，当短信到来时它可以先接受到短信广播，必要时终止广播传递，这样的软件就必须声明接收短信的权限。此处可以自定义属性*/ LocalBroadcastManager无论是系统还是应用的广播在每个进程都是可以监听到的，有可能造成数据被监听到，在android-support-v4.jar中引入了LocalBroadcastManager，称为局部通知管理器，这种通知的好处是安全性高，效率也高，适合局部通信，可以用来代替Handler更新UI（一般不会使用广播去做这些事情，可以使用EventBus） 123456789101112131415send:LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(getActivity());IntentFilter filter = new IntentFilter();filter.addAction(ACTION);myBroadcastReciver = new MyBroadcastReciver();localBroadcastManager.registerReceiver(myBroadcastReciver, filter);receive:Intent intent = new Intent();intent.setAction(ACTION);intent.putExtra(TAG, data);LocalBroadcastManager.getInstance(getActivity()).sendBroadcast(intent); 引用 基础总结篇之五：BroadcastReceiver应用详解","tags":[{"name":"Broadcast","slug":"Broadcast","permalink":"http://yoursite.com/tags/Broadcast/"}]},{"title":"Android之Activity","date":"2017-04-22T02:11:41.000Z","path":"2017/04/22/Android之Activity/","text":"Activity一个应用程序的组件，它提供一个屏幕来与用户交互。 从下面几个方面研究activity： 生命周期 状态保存 task相关 生命周期 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-&gt;启动apponCreateonStartonResumeonWindowFocusChanged-&gt; APP运行中。。。。-&gt; Home跳到桌面onWindowFocusChangedonPauseonSaveInstanceStateonStop-&gt; 从桌面返回ActivityonRestartonStartonResumeonWindowFocusChanged-&gt;调用dialogonWindowFocusChanged-&gt;取消dialogonWindowFocusChanged-&gt;跳到另外一个ActivityonPauseonWindowFocusChangedonSaveInstanceStateonStop-&gt;返回原来的ActivityonRestartonStartonResumeonWindowFocusChanged-&gt; 结束当前AcitivityonPauseonWindowFocusChangedonStoponDestroy 默认情况下横竖屏切换时 Activity 的生命周期 12345678910111213141516171819202122232425262728293031-&gt;启动app(初始为竖屏)onCreateonStartonResumeonWindowFocusChanged-&gt;切横屏onPauseonSaveInstanceStateonStoponDestroyonCreateonStartonRestoreInstanceStateonResumeonWindowFocusChanged-&gt; 切回竖屏onPauseonSaveInstanceStateonStoponDestroyonCreateonStartonRestoreInstanceStateonResumeonWindowFocusChanged 设置configChanges时的生命周期 android:configChanges=”orientation”，生命周期与默认设置一样 设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 如何保存 Activity 的状态上面提到了当activity在后台被销毁后，重新返回这个activity时会重新调用onCreat，那么之前页面的状态又会变成初始状态。这里我们可以在onSaveInstanceState里面保存我们的数据，onCreate(Bundle savedInstanceState)的参数就是我们保存的数据。 12345678910111213141516@Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (savedInstanceState != null &amp;&amp; savedInstanceState.getInt(&quot;state&quot;) != 0) &#123; int state = savedInstanceState.getInt(&quot;savedInstanceState.getInt(&quot;state&quot;)&quot;); &#125; &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; outState.putInt(&quot;state&quot;, data); super.onSaveInstanceState(outState); &#125; task和back stack（需要研究ActivityManagerService）深入理解ActivityManagerService launchMode在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。这里简单介绍一下task的概念，task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。launchMode包括以下几种： standard singleTop singleTask singleInstance 网上的博文只讲了一些简单的用法，但在写demo的时候发现很多特殊的情况，比如taskAffinity会对singleTask有影响，所以更详细的研究打算放到以后有机会研究framework时再深究，下面先mark几遍写的全面的blog Android中Activity四种启动模式和taskAffinity属性详解基础总结篇之二：Activity的四种launchModeAndroid 开发指南（一） 任务Task及回收栈back stack介绍 adb shell dumpsys activity 引用：Android 面试题–Activity","tags":[{"name":"activity","slug":"activity","permalink":"http://yoursite.com/tags/activity/"}]},{"title":"Java（一）：概述","date":"2017-04-22T02:11:41.000Z","path":"2017/04/22/Java（一）：概述/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"工具","date":"2017-04-20T10:45:23.000Z","path":"2017/04/20/Tools/","text":"拥有工具你就拥有全世界 LICEcap 动画屏幕录制软件，支持导出 GIF 动画图片格式，轻量级、高质量（每帧颜色数量可超过256）、使用简单，录制过程中可以随意改变录屏范围。","tags":[]},{"title":"使用hexo搭建个人博客（N）：有一些东西觉得很好的，但暂时没整理好，先记录下来，也欢迎各位来补充","date":"2017-04-20T08:34:11.000Z","path":"2017/04/20/hexo待整理/","text":"Hexo如何在线可视化写博客,省去每次修改都要敲命令markdown toc","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"优秀资源","date":"2017-04-20T07:58:31.000Z","path":"2017/04/20/优秀资源/","text":"站在巨人肩上，就能看得更高。巨人（资源）是有了，那么第一步就是要爬到巨人肩上（消化资源）。 博客鸿洋 stormzhang 美团技术团队 郭霖 codekk 稀土掘金 妹子 AndroidWeekly fir_im 单元测试键盘男依赖注入神器：Dagger2详解系列 gradle深入理解Android（一）：Gradle详解Gradle的高级技巧 githubAndroid开发人员不得不收集的代码 书籍urlAndroid 项目代码质量保证实践How browsers work–Behind the scenes of modern web browsers （前端必读）Android高工必备技能Android开发——JVM、Dalvik以及ART的区别targetSdkVersion 架构Android架构思考(模块化、多进程)","tags":[{"name":"优秀资源","slug":"优秀资源","permalink":"http://yoursite.com/tags/优秀资源/"}]},{"title":"使用hexo搭建个人博客（五）：各种炫酷插件","date":"2017-04-20T07:34:11.000Z","path":"2017/04/20/使用hexo搭建个人博客（五）：各种炫酷插件/","text":"装逼必备，↓↓（表示各种没版权） 网易云音乐插件 生成代码粘贴到你的博文就可以了。 网页统计不蒜子，两行代码搞定","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"使用hexo搭建个人博客（四）：博文编辑","date":"2017-04-20T06:34:11.000Z","path":"2017/04/20/使用hexo搭建个人博客（四）：博文编辑/","text":"介绍编辑博文的一些基本参数 在新建博文的时候，hexo会根据你的模板在source/_posts生成一个文件： 1234title: new articledate: timetags:--- 文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文,支持markdown格式. 属性 描述 默认值 layout 模板类型 post title 文章标题 date 创建日期 updated 修改日期 comments 是否开启评论 tags 标签 categories 分类 permalink url中的名字 文件名 在首页不想展示博文太多内容的时候可以使用","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"使用hexo搭建个人博客（三）：目录结构以及每个文件的作用","date":"2017-04-20T03:34:11.000Z","path":"2017/04/20/使用hexo搭建个人博客（三）：目录结构以及每个文件的作用/","text":"对工程有初步了解 主工程文件结构123456789101112131415.├── .deploy #执行hexo deploy命令部署到GitHub上的内容目录├── public #执行hexo generate命令，输出的静态网页内容目录├── scaffolds #layout模板文件目录，生成对应文件的模板│ ├── draft.md │ ├── page.md │ └── post.md ├── scripts #扩展脚本目录，这里可以自定义一些javascript脚本├── source #博文源码目录| ├── _drafts| ├── _posts| └── favicon.ico 这个是最终生成的博客网站的图标├── themes #主题文件目录├── _config.yml #全局配置文件└── package.json #npm配置文件 scaffolds下的模板使用方法 1234hexo new post xxxhexo new draft xxxhexo new page xxx也可以自己自定义模板，新建的文件则会保存到source/_post目录下 source下面的文件 除 posts 文件夹之外，开头命名为 (下划线)的文件/ 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"使用hexo搭建个人博客（二）：配置文件","date":"2017-04-19T11:20:31.000Z","path":"2017/04/19/使用hexo搭建个人博客（二）：配置文件/","text":"简单修改就可以配置自己的博客 所有的配置项后面的冒号（:）与值之间要有一个空格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# **Site 网站信息**title: 网站标题subtitle: 网站副标题description: 网站描述author: 网站作者名字language: #网站语言,默认是英语(en)timezone: #网站时区# URL 网站设置## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: seayxu.github.io #网站的地址root: / #网站的根目录，如果是子文件夹下，则填写子文件夹路径permalink: :year/:month/:day/:title/ #文章链接地址格式 permalink_defaults: # Directory 目录设置source_dir: source #资源文件夹，默认是sourcepublic_dir: public #公共文件夹，默认是publictag_dir: tags #标签文件夹，默认是tagsarchive_dir: archives #档案文件夹，默认是archivescategory_dir: categories #分类文件夹，默认是categoriescode_dir: downloads/code #代码文件夹，默认是downloads/codei18n_dir: :lang #国际化文件夹，默认跟language相同skip_render: [] #不需要渲染的文件夹或文件夹,放在[]中# Writing 文章写作选项new_post_name: :title.md # File name of new postsdefault_layout: post #默认布局模板titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #高亮显示 enable: true #默认开启 line_number: true #显示行号，默认开启 auto_detect: false tab_replace:# Category &amp; Tag 分类和标签default_category: uncategorized #默认分类名称category_map:tag_map:# Date / Time format #日期/时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式# Pagination #分页信息## Set per_page to 0 to disable paginationper_page: 10 #每页显示数量，设置为0表示不启用分页pagination_dir: page #分页文件夹名称# Extensions 扩展## Plugins: https://hexo.io/plugins/ #插件plugins: hexo-generator-feed #RSS订阅插件 hexo-generator-sitemap #sitemap插件## Themes: https://hexo.io/themes/ #主题theme: landscape #主体名称# Deployment 部署## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:SeayXu/seayxu.github.io.git #github仓库地址 branch: master # github分支","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"使用hexo搭建个人博客（一）：配置环境","date":"2017-04-19T09:20:31.000Z","path":"2017/04/19/使用hexo搭建个人博客（一）：配置环境/","text":"技术要求： 开发：npm&amp;hexo &nbsp;&nbsp;&nbsp;&nbsp; 熟悉几条命令即可 部署：git &nbsp;&nbsp;&nbsp;&nbsp; 最好掌握，git本身也是神器 博文编辑：markdown &nbsp;&nbsp;&nbsp;&nbsp; 会一点html会使布局更如意 图片存储：七牛 搭建流程：开发环境配置 安装Node.js 点击安装node.js 安装hexo 1npm install -g hexo 新建文件夹，在文件夹里面执行 1hexo init #Hexo会自动在目标文件夹建立网站所需要的文件 初始化项目 1npm install 生成静态页面 1hexo generate #或者 hexo g 启动本地服务，预览 12hexo server #或者 hexo s在浏览器输入http://localhost:4000 博文编辑 windows下markdown编辑器：MarkdownPad hexo new “postName” #新建文章 编辑博文后，hexo generate -&gt; hexo server -g -&gt; http://localhost:4000 初步的效果已经有了，后面会专门用一遍来讲。 主题更换 在你的博客文件夹（假设为/hexo）下面clone你想要的theme git clone git@github.com:litten/hexo-theme-yilia.git 在/hexo/_config.yml，修改主题为yilia hexo generate -&gt; hexo server -g -&gt; http://localhost:4000(此步每次修改文件后都要执行才能查看效果) 部署到github 部署到github后你可以在使用其他设备通过浏览器访问你的博客 在你的github账户下新建repository，repository的名字要设为your_user_name.github.io 编辑 /hexo/_config.yml: 1234deploy: type: github repository: your_user_name.github.io仓库的地址 branch: master 执行命令 提交前要配置好ssh 12hexo generatehexo deploy hexo命令概述1234567891011121314 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHubhexo clean-------命令简化hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deployhexo deploy -g -&gt; hexo g + hexo d hexo server -g -&gt; hexo g + hexo s","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"搭建自己的博客（Hexo + Github）","date":"2017-04-19T08:05:50.000Z","path":"2017/04/19/hexo/","text":"前言What is Hexo? &nbsp;&nbsp;&nbsp;&nbsp;Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds. &nbsp;&nbsp;&nbsp;&nbsp;身为一个屌丝程序猿，大神的博客就是我的救命稻草，于是总想自己也弄个博客。之前在CSDN注册了账号，但是总是缺乏动力去维护，一方面是编辑需要大量时间（主要也是太懒了），二是感觉发重复的东西没什么用。 &nbsp;&nbsp;无意中发现Hexo后，顿时想装一下逼。其实真正的理由是真的想把自己找到的资料好好整理一遍，记录下来，方便日后翻阅，然后像大神一样分享给大家。 &nbsp;&nbsp;&nbsp;&nbsp;这是一遍我从零开始使用Hexo的流程，本人也不是搞前端的，所以源码很多东西都不知道怎么修改，日后会慢慢补充。 模板下面列出一些个人比较喜欢的Hexo模板，各位自行挑选食用 NexT 精于心，简于形(分类做的很好) Yilia 没错就是博主的theme Hueman 高大上，适合设计师服用 raytaylorism Material Design,Android专用有木有 以下地方也可以找到更多 知乎 -&gt; 有哪些好看的 Hexo 主题？ hexo官网themes 核心部分现在开始从零开始搭建Hexo吧。。。。 &nbsp;&nbsp;&nbsp;&nbsp;使用hexo搭建个人博客（一）：配置环境&nbsp;&nbsp;&nbsp;&nbsp;使用hexo搭建个人博客（二）：配置文件&nbsp;&nbsp;&nbsp;&nbsp;使用hexo搭建个人博客（三）：目录结构以及每个文件的作用&nbsp;&nbsp;&nbsp;&nbsp;使用hexo搭建个人博客（四）：博文编辑&nbsp;&nbsp;&nbsp;&nbsp;使用hexo搭建个人博客（五）：各种炫酷插件&nbsp;&nbsp;&nbsp;&nbsp;使用hexo搭建个人博客（N）：有一些东西觉得很好的，但暂时没整理好，先记录下来，也欢迎各位来补充","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]